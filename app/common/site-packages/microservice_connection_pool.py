# Copyright (C) 2022 Georgia Tech Center for Experimental Research in Computer
# Systems

import queue
import random
import threading
import time


class MicroserviceConnectionPool:

  def __init__(self, local_service_name, remote_service_name,
               remote_service_client_class, servers, pool_min_size,
               pool_max_size, allow_ephemeral, rpc_conn_logger):
    self._local_service_name = local_service_name
    self._remote_service_name = remote_service_name
    self._remote_service_client_class = remote_service_client_class
    self._servers = servers
    self._pool_min_size = pool_min_size
    self._pool_max_size = pool_max_size
    self._allow_ephemeral = allow_ephemeral
    self._rpc_conn_logger = rpc_conn_logger
    self._pool_current_size = 0
    self._backlog_len = 0
    self._conn_pool = queue.Queue()
    self._conn_pool_lock = threading.Lock()
    self._conn_pool_condition = threading.Condition(self._conn_pool_lock)
    # Validate connection pool parameters.
    assert (self._pool_min_size >= 0)
    assert (self._pool_max_size >= 0)
    assert (self._pool_max_size >= self._pool_min_size)

  def get_client(self):
    start_time = time.monotonic()
    backlog_len = 0
    conn = None
    server = None
    if self._pool_max_size > 0:
      self._conn_pool_lock.acquire()
      if self._pool_current_size < self._pool_min_size:
        server = self._servers[self._pool_current_size % len(self._servers)]
        self._pool_current_size += 1
        conn = self._remote_service_client_class(server.split(':')[0],
                                                 int(server.split(':')[1]),
                                                 connection_pool=self)
      elif not self._conn_pool.empty():
        conn = self._conn_pool.get(block=True, timeout=None)
      elif self._pool_current_size < self._pool_max_size or self._allow_ephemeral:
        server = self._servers[self._pool_current_size % len(self._servers)]
        self._pool_current_size += 1
        conn = self._remote_service_client_class(server.split(':')[0],
                                                 int(server.split(':')[1]),
                                                 connection_pool=self)
      else:
        self._backlog_len += 1
        backlog_len = self._backlog_len
        while self._conn_pool.empty():
          self._conn_pool_condition.wait()
        self._backlog_len -= 1
        conn = self._conn_pool.get(block=True, timeout=None)
      self._conn_pool_lock.release()
    else:
      server = random.choice(self._servers)
      conn = self._remote_service_client_class(server.split(':')[0],
                                               int(server.split(':')[1]),
                                               connection_pool=self)
    latency = time.monotonic() - start_time
    if self._rpc_conn_logger:
      self._rpc_conn_logger.info(
          "ls=%s rs=%s bl=%s lat=%.9f" %
          (self._local_service_name, self._remote_service_name, backlog_len,
           latency))
    return conn

  def release_client(self, conn):
    if self._pool_max_size > 0:
      self._conn_pool_lock.acquire()
      if self._pool_current_size > self._pool_max_size or (
          self._pool_current_size > self._pool_min_size and
          self._conn_pool.qsize() > 1):
        conn.close()
        self._pool_current_size -= 1
      else:
        self._conn_pool.put(conn)
        self._conn_pool_condition.notify()
      self._conn_pool_lock.release()
    else:
      conn.close()
